<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stopwatch</title>
  <style>
    :root {
      --bg: #f5f5f5;
      --primary: #0074d9;
    }

    body {
      font-family: system-ui, sans-serif;
      background: var(--bg);
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 1rem;
    }

    #time {
      font-size: 4rem;
      letter-spacing: 0.05em;
    }

    button {
      font-size: 1rem;
      padding: 0.5rem 1.5rem;
      margin: 0 0.25rem;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      background: var(--primary);
      color: #fff;
    }

    button:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    /* Idle overlay */
    #idleOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      z-index: 1000;
      text-align: center;
      padding: 1rem;
    }
    #idleOverlay button {
      background: #2ecc40;
      box-shadow: none;
    }
  </style>
</head>
<body>
  <div id="time">00:00.00</div>
  <div>
    <button id="start">Start</button>
    <button id="stop">Stop</button>
    <button id="reset">Reset</button>
  </div>

  <!-- Idle overlay -->
  <div id="idleOverlay">
    <h2>You've been inactive for 2&nbsp;minutes.</h2>
    <p>The timer is paused.</p>
    <button id="resumeBtn">I'm back</button>
  </div>

  <script>
    (() => {
      const TICK = 100;              // update interval (ms)
      const SLEEP_THRESHOLD = 60_000; // gap >1 min is treated as sleep
      const IDLE_THRESHOLD = 120_000; // 2‑minute idle pause

      const display = document.getElementById("time");
      const idleOverlay = document.getElementById("idleOverlay");
      const resumeBtn = document.getElementById("resumeBtn");

      let startTime = null;      // ms since epoch when current run started
      let elapsedBefore = 0;     // accumulated ms from previous runs
      let timerId = null;
      let lastNow = 0;           // last Date.now() captured

      // Idle Detector state
      let idleDetectorInitialized = false;
      let idleDetector = null;

      /** Format ms -> HH:MM:SS.hh (omit hours if 0). */
      function format(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor(totalSeconds / 60) % 60;
        const seconds = totalSeconds % 60;
        const hundredths = Math.floor((ms % 1000) / 10);
        return (
          (hours ? String(hours).padStart(2, "0") + ":" : "") +
          String(minutes).padStart(2, "0") + ":" +
          String(seconds).padStart(2, "0") + "." +
          String(hundredths).padStart(2, "0")
        );
      }

      /** Update page and tab title. */
      function render(ms) {
        const text = format(ms);
        display.textContent = text;
        document.title = text;
      }

      /** Tick handler compensating for system sleep. */
      function tick() {
        const now = Date.now();
        const delta = now - lastNow;
        lastNow = now;
        if (delta > SLEEP_THRESHOLD) {
          // computer likely slept; exclude the extra gap
          startTime += delta;
        }
        const elapsed = now - startTime + elapsedBefore;
        render(elapsed);
      }

      function start() {
        if (timerId) return; // already running
        startTime = Date.now();
        lastNow = startTime;
        timerId = setInterval(tick, TICK);
        // Attempt to init Idle Detector on a **user gesture** (this click)
        maybeInitIdleDetector();
      }

      function stop() {
        if (!timerId) return;
        clearInterval(timerId);
        timerId = null;
        elapsedBefore += Date.now() - startTime;
        render(elapsedBefore);
      }

      function reset() {
        stop();
        elapsedBefore = 0;
        render(0);
      }

      // Buttons
      document.getElementById("start").addEventListener("click", start);
      document.getElementById("stop").addEventListener("click", stop);
      document.getElementById("reset").addEventListener("click", reset);
      resumeBtn.addEventListener("click", () => {
        idleOverlay.style.display = "none";
        start();
      });

      /* -----------------------------------------
         Idle Detection (Chromium‑based browsers)
         ----------------------------------------- */
      async function maybeInitIdleDetector() {
        if (idleDetectorInitialized || !("IdleDetector" in window)) return;
        idleDetectorInitialized = true;

        try {
          const perm = await IdleDetector.requestPermission();
          if (perm !== "granted") return;

          idleDetector = new IdleDetector();
          idleDetector.addEventListener("change", () => {
            const { userState, screenState } = idleDetector;
            const idle = userState === "idle" || screenState === "locked";
            if (idle) {
              stop();
              idleOverlay.style.display = "flex";
            }
          });
          await idleDetector.start({ threshold: IDLE_THRESHOLD });
        } catch (err) {
          console.error("IdleDetector init error:", err);
        }
      }

      // Initial paint
      render(0);
    })();
  </script>
</body>
</html>
