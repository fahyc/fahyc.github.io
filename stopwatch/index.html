<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stopwatch</title>
  <style>
    :root {
      --bg: #f5f5f5;
      --primary: #0074d9;
    }

    body {
      font-family: system-ui, sans-serif;
      background: var(--bg);
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 1rem;
    }

    #time {
      font-size: 4rem;
      letter-spacing: 0.05em;
    }

    button {
      font-size: 1rem;
      padding: 0.5rem 1.5rem;
      margin: 0 0.25rem;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      background: var(--primary);
      color: #fff;
    }

    button:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    /* Idle overlay */
    #idleOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      z-index: 1000;
      text-align: center;
      padding: 1rem;
    }
    #idleOverlay button {
      background: #2ecc40;
      box-shadow: none;
    }
  </style>
</head>
<body>
  <div id="time">00:00.00</div>
  <div>
    <button id="start">Start</button>
    <button id="stop">Stop</button>
    <button id="reset">Reset</button>
  </div>

  <!-- Idle overlay -->
  <div id="idleOverlay">
    <h2>You've been inactive for 2&nbsp;minutes.</h2>
    <p>The timer is paused.</p>
    <button id="resumeBtn">I'm back</button>
  </div>

  <script>
    (() => {
      const TICK = 100;                // update interval (ms)
      const SLEEP_THRESHOLD = 60_000;  // gap >1 min is treated as sleep
      const IDLE_THRESHOLD = 120_000;  // 2‑minute idle pause

      const display = document.getElementById("time");
      const idleOverlay = document.getElementById("idleOverlay");
      const resumeBtn = document.getElementById("resumeBtn");

      let startTime = null;      // ms since epoch when current run started
      let elapsedBefore = 0;     // accumulated ms from previous runs
      let timerId = null;
      let lastNow = 0;           // last Date.now() captured

      // Idle Detector state
      let idleDetectorInitialized = false;
      let idleDetector = null;

      // Attention helpers
      let blinkInterval = null;
      let originalTitle = document.title;

      /** Format ms -> HH:MM:SS.hh (omit hours if 0). */
      function format(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor(totalSeconds / 60) % 60;
        const seconds = totalSeconds % 60;
        const hundredths = Math.floor((ms % 1000) / 10);
        return (
          (hours ? String(hours).padStart(2, "0") + ":" : "") +
          String(minutes).padStart(2, "0") + ":" +
          String(seconds).padStart(2, "0") + "." +
          String(hundredths).padStart(2, "0")
        );
      }

      /** Update page and tab title. */
      function render(ms) {
        const text = format(ms);
        display.textContent = text;
        document.title = text;
        // keep originalTitle up to date for blinking reset
        if (!blinkInterval) originalTitle = text;
      }

      /** Clears blinking title & app badge. */
      function clearAttention() {
        if (blinkInterval) {
          clearInterval(blinkInterval);
          blinkInterval = null;
          document.title = originalTitle;
        }
        if ("clearAppBadge" in navigator) navigator.clearAppBadge();
      }

      /** Emits OS notification, beep, or blinking title */
      function attentionPunch() {
        // Native notification first
        if ("Notification" in window && Notification.permission === "granted") {
          const n = new Notification("Timer paused (inactive 2 min)", {
            body: "Click to resume",
            requireInteraction: true
          });
          n.onclick = () => {
            window.focus();
            resumeBtn.click();
          };
          if ("setAppBadge" in navigator) navigator.setAppBadge(1);
          return;
        }

        // Fallback: short beep
        try {
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          const osc = ctx.createOscillator();
          osc.frequency.value = 440;
          osc.connect(ctx.destination);
          osc.start();
          osc.stop(ctx.currentTime + 0.15);
        } catch {/* ignore */}

        // Fallback: blink title
        if (!blinkInterval) {
          blinkInterval = setInterval(() => {
            document.title = document.title.startsWith("⚠️ ") ? originalTitle : "⚠️ " + originalTitle;
          }, 800);
          window.addEventListener("focus", clearAttention, { once: true });
        }
      }

      /** Tick handler compensating for system sleep. */
      function tick() {
        const now = Date.now();
        const delta = now - lastNow;
        lastNow = now;
        if (delta > SLEEP_THRESHOLD) {
          // computer likely slept; exclude the extra gap
          startTime += delta;
        }
        const elapsed = now - startTime + elapsedBefore;
        render(elapsed);
      }

      function start() {
        clearAttention();
        if (timerId) return; // already running
        startTime = Date.now();
        lastNow = startTime;
        timerId = setInterval(tick, TICK);
        maybeInitIdleDetector(); // user gesture
      }

      function stop() {
        if (!timerId) return;
        clearInterval(timerId);
        timerId = null;
        elapsedBefore += Date.now() - startTime;
        render(elapsedBefore);
      }

      function reset() {
        stop();
        elapsedBefore = 0;
        render(0);
      }

      // Button wiring
      document.getElementById("start").addEventListener("click", start);
      document.getElementById("stop").addEventListener("click", stop);
      document.getElementById("reset").addEventListener("click", reset);
      resumeBtn.addEventListener("click", () => {
        idleOverlay.style.display = "none";
        start();
      });

      /* --------------------------------------------------
         Idle Detection (Chromium‑based, secure contexts)
         -------------------------------------------------- */
      async function maybeInitIdleDetector() {
        if (idleDetectorInitialized) return;
        if (!("IdleDetector" in window) || !window.isSecureContext) {
          console.warn("Idle Detection API unavailable. Stopwatch works, but no auto‑pause.");
          idleDetectorInitialized = true;
          return;
        }

        idleDetectorInitialized = true;
        try {
          // Ask for Notification permission while we have a user gesture
          if ("Notification" in window && Notification.permission === "default") {
            await Notification.requestPermission();
          }

          const perm = await IdleDetector.requestPermission();
          if (perm !== "granted") {
            console.warn("Idle detection permission denied.");
            return;
          }

          idleDetector = new IdleDetector();
          idleDetector.addEventListener("change", () => {
            const { userState, screenState } = idleDetector;
            const idle = userState === "idle" || screenState === "locked";
            if (idle) {
              stop();
              idleOverlay.style.display = "flex";
              attentionPunch();
            }
          });
          await idleDetector.start({ threshold: IDLE_THRESHOLD });
        } catch (err) {
          console.warn("Idle Detection unavailable:", err);
        }
      }

      // Initial paint
      render(0);
    })();
  </script>
</body>
</html>
